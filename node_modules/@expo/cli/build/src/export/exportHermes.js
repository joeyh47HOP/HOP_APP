"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.importHermesCommandFromProject = importHermesCommandFromProject;
exports.isEnableHermesManaged = isEnableHermesManaged;
exports.buildHermesBundleAsync = buildHermesBundleAsync;
exports.createHermesSourcemapAsync = createHermesSourcemapAsync;
exports.parseGradleProperties = parseGradleProperties;
exports.maybeThrowFromInconsistentEngineAsync = maybeThrowFromInconsistentEngineAsync;
exports.maybeInconsistentEngineAndroidAsync = maybeInconsistentEngineAndroidAsync;
exports.maybeInconsistentEngineIosAsync = maybeInconsistentEngineIosAsync;
exports.isHermesBytecodeBundleAsync = isHermesBytecodeBundleAsync;
exports.getHermesBytecodeBundleVersionAsync = getHermesBytecodeBundleVersionAsync;
var _spawnAsync = _interopRequireDefault(require("@expo/spawn-async"));
var _fsExtra = _interopRequireDefault(require("fs-extra"));
var _os = _interopRequireDefault(require("os"));
var _path = _interopRequireDefault(require("path"));
var _process = _interopRequireDefault(require("process"));
var _resolveFromProject = require("../start/server/metro/resolveFromProject");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function importHermesCommandFromProject(projectRoot) {
    const platformExecutable = getHermesCommandPlatform();
    const hermescLocations = [
        // Override hermesc dir by environment variables
        _process.default.env["REACT_NATIVE_OVERRIDE_HERMES_DIR"] ? `${_process.default.env["REACT_NATIVE_OVERRIDE_HERMES_DIR"]}/build/bin/hermesc` : "",
        // Building hermes from source
        "react-native/ReactAndroid/hermes-engine/build/hermes/bin/hermesc",
        // Prebuilt hermesc in official react-native 0.69+
        `react-native/sdks/hermesc/${platformExecutable}`,
        // Legacy hermes-engine package
        `hermes-engine/${platformExecutable}`, 
    ];
    for (const location of hermescLocations){
        try {
            return (0, _resolveFromProject).resolveFromProject(projectRoot, location);
        } catch  {}
    }
    throw new Error("Cannot find the hermesc executable.");
}
function getHermesCommandPlatform() {
    switch(_os.default.platform()){
        case "darwin":
            return "osx-bin/hermesc";
        case "linux":
            return "linux64-bin/hermesc";
        case "win32":
            return "win64-bin/hermesc.exe";
        default:
            throw new Error(`Unsupported host platform for Hermes compiler: ${_os.default.platform()}`);
    }
}
function isEnableHermesManaged(expoConfig, platform) {
    switch(platform){
        case "android":
            {
                var ref;
                var ref1;
                return ((ref1 = (ref = expoConfig.android) == null ? void 0 : ref.jsEngine) != null ? ref1 : expoConfig.jsEngine) !== "jsc";
            }
        case "ios":
            {
                var ref2;
                var ref3;
                return ((ref3 = (ref2 = expoConfig.ios) == null ? void 0 : ref2.jsEngine) != null ? ref3 : expoConfig.jsEngine) !== "jsc";
            }
        default:
            return false;
    }
}
async function buildHermesBundleAsync(projectRoot, { code , map , minify =false  }) {
    const tempDir = _path.default.join(_os.default.tmpdir(), `expo-bundler-${_process.default.pid}`);
    await _fsExtra.default.ensureDir(tempDir);
    try {
        const tempBundleFile = _path.default.join(tempDir, "index.bundle");
        await _fsExtra.default.writeFile(tempBundleFile, code);
        if (map) {
            const tempSourcemapFile = _path.default.join(tempDir, "index.bundle.map");
            await _fsExtra.default.writeFile(tempSourcemapFile, map);
        }
        const tempHbcFile = _path.default.join(tempDir, "index.hbc");
        const hermesCommand = importHermesCommandFromProject(projectRoot);
        const args = [
            "-emit-binary",
            "-out",
            tempHbcFile,
            tempBundleFile
        ];
        if (minify) {
            args.push("-O");
        }
        if (map) {
            args.push("-output-source-map");
        }
        await (0, _spawnAsync).default(hermesCommand, args);
        let hbc;
        let sourcemap = null;
        if (!map) {
            hbc = await _fsExtra.default.readFile(tempHbcFile);
        } else {
            [hbc, sourcemap] = await Promise.all([
                _fsExtra.default.readFile(tempHbcFile),
                createHermesSourcemapAsync(projectRoot, map, `${tempHbcFile}.map`), 
            ]);
        }
        return {
            hbc,
            sourcemap
        };
    } finally{
        await _fsExtra.default.remove(tempDir);
    }
}
async function createHermesSourcemapAsync(projectRoot, sourcemap, hermesMapFile) {
    const composeSourceMaps = (0, _resolveFromProject).importMetroSourceMapComposeSourceMapsFromProject(projectRoot);
    const bundlerSourcemap = JSON.parse(sourcemap);
    const hermesSourcemap = await _fsExtra.default.readJSON(hermesMapFile);
    return JSON.stringify(composeSourceMaps([
        bundlerSourcemap,
        hermesSourcemap
    ]));
}
function parseGradleProperties(content) {
    const result = {};
    for (let line of content.split("\n")){
        line = line.trim();
        if (!line || line.startsWith("#")) {
            continue;
        }
        const sepIndex = line.indexOf("=");
        const key = line.substr(0, sepIndex);
        const value = line.substr(sepIndex + 1);
        result[key] = value;
    }
    return result;
}
async function maybeThrowFromInconsistentEngineAsync(projectRoot, configFilePath, platform, isHermesManaged) {
    const configFileName = _path.default.basename(configFilePath);
    if (platform === "android" && await maybeInconsistentEngineAndroidAsync(projectRoot, isHermesManaged)) {
        throw new Error(`JavaScript engine configuration is inconsistent between ${configFileName} and Android native project.\n` + `In ${configFileName}: Hermes is ${isHermesManaged ? "enabled" : "not enabled"}\n` + `In Android native project: Hermes is ${isHermesManaged ? "not enabled" : "enabled"}\n` + `Please check the following files for inconsistencies:\n` + `  - ${configFilePath}\n` + `  - ${_path.default.join(projectRoot, "android", "gradle.properties")}\n` + `  - ${_path.default.join(projectRoot, "android", "app", "build.gradle")}\n` + "Learn more: https://expo.fyi/hermes-android-config");
    }
    if (platform === "ios" && await maybeInconsistentEngineIosAsync(projectRoot, isHermesManaged)) {
        throw new Error(`JavaScript engine configuration is inconsistent between ${configFileName} and iOS native project.\n` + `In ${configFileName}: Hermes is ${isHermesManaged ? "enabled" : "not enabled"}\n` + `In iOS native project: Hermes is ${isHermesManaged ? "not enabled" : "enabled"}\n` + `Please check the following files for inconsistencies:\n` + `  - ${configFilePath}\n` + `  - ${_path.default.join(projectRoot, "ios", "Podfile")}\n` + `  - ${_path.default.join(projectRoot, "ios", "Podfile.properties.json")}\n` + "Learn more: https://expo.fyi/hermes-ios-config");
    }
}
async function maybeInconsistentEngineAndroidAsync(projectRoot, isHermesManaged) {
    // Trying best to check android native project if by chance to be consistent between app config
    // Check gradle.properties from prebuild template
    const gradlePropertiesPath = _path.default.join(projectRoot, "android", "gradle.properties");
    if (_fsExtra.default.existsSync(gradlePropertiesPath)) {
        const props = parseGradleProperties(await _fsExtra.default.readFile(gradlePropertiesPath, "utf8"));
        const isHermesBare = props["hermesEnabled"] === "true";
        if (isHermesManaged !== isHermesBare) {
            return true;
        }
    }
    return false;
}
async function maybeInconsistentEngineIosAsync(projectRoot, isHermesManaged) {
    // Trying best to check ios native project if by chance to be consistent between app config
    // Check ios/Podfile for ":hermes_enabled => true"
    const podfilePath = _path.default.join(projectRoot, "ios", "Podfile");
    if (_fsExtra.default.existsSync(podfilePath)) {
        const content = await _fsExtra.default.readFile(podfilePath, "utf8");
        const isPropsReference = content.search(/^\s*:hermes_enabled\s*=>\s*podfile_properties\['expo.jsEngine'\]\s*==\s*nil\s*\|\|\s*podfile_properties\['expo.jsEngine'\]\s*==\s*'hermes',?/m) >= 0;
        const isHermesBare = content.search(/^\s*:hermes_enabled\s*=>\s*true,?\s+/m) >= 0;
        if (!isPropsReference && isHermesManaged !== isHermesBare) {
            return true;
        }
    }
    // Check Podfile.properties.json from prebuild template
    const podfilePropertiesPath = _path.default.join(projectRoot, "ios", "Podfile.properties.json");
    if (_fsExtra.default.existsSync(podfilePropertiesPath)) {
        const props = await parsePodfilePropertiesAsync(podfilePropertiesPath);
        const isHermesBare = props["expo.jsEngine"] === "hermes";
        if (isHermesManaged !== isHermesBare) {
            return true;
        }
    }
    return false;
}
// https://github.com/facebook/hermes/blob/release-v0.5/include/hermes/BCGen/HBC/BytecodeFileFormat.h#L24-L25
const HERMES_MAGIC_HEADER = "c61fbc03c103191f";
async function isHermesBytecodeBundleAsync(file) {
    const header = await readHermesHeaderAsync(file);
    return header.slice(0, 8).toString("hex") === HERMES_MAGIC_HEADER;
}
async function getHermesBytecodeBundleVersionAsync(file) {
    const header = await readHermesHeaderAsync(file);
    if (header.slice(0, 8).toString("hex") !== HERMES_MAGIC_HEADER) {
        throw new Error("Invalid hermes bundle file");
    }
    return header.readUInt32LE(8);
}
async function readHermesHeaderAsync(file) {
    const fd = await _fsExtra.default.open(file, "r");
    const buffer = Buffer.alloc(12);
    await _fsExtra.default.read(fd, buffer, 0, 12, null);
    await _fsExtra.default.close(fd);
    return buffer;
}
async function parsePodfilePropertiesAsync(podfilePropertiesPath) {
    try {
        return JSON.parse(await _fsExtra.default.readFile(podfilePropertiesPath, "utf8"));
    } catch  {
        return {};
    }
}

//# sourceMappingURL=exportHermes.js.map