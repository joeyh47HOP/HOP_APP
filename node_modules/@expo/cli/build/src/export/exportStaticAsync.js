"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.unstable_exportStaticAsync = unstable_exportStaticAsync;
exports.getFilesToExportFromServerAsync = getFilesToExportFromServerAsync;
exports.exportFromServerAsync = exportFromServerAsync;
exports.modifyBundlesWithSourceMaps = modifyBundlesWithSourceMaps;
exports.getHtmlFiles = getHtmlFiles;
exports.getPathVariations = getPathVariations;
var _config = require("@expo/config");
var _assert = _interopRequireDefault(require("assert"));
var _chalk = _interopRequireDefault(require("chalk"));
var _fs = _interopRequireDefault(require("fs"));
var _path = _interopRequireDefault(require("path"));
var _prettyBytes = _interopRequireDefault(require("pretty-bytes"));
var _util = require("util");
var _favicon = require("./favicon");
var _log = require("../log");
var _devServerManager = require("../start/server/DevServerManager");
var _metroBundlerDevServer = require("../start/server/metro/MetroBundlerDevServer");
var _metroErrorInterface = require("../start/server/metro/metroErrorInterface");
var _router = require("../start/server/metro/router");
var _link = require("../utils/link");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const debug = require("debug")("expo:export:generateStaticRoutes");
async function unstable_exportStaticAsync(projectRoot, options) {
    _log.Log.warn(`Experimental static rendering is enabled. ` + (0, _link).learnMore("https://docs.expo.dev/router/reference/static-rendering/"));
    // TODO: Prevent starting the watcher.
    const devServerManager = new _devServerManager.DevServerManager(projectRoot, {
        minify: options.minify,
        mode: "production",
        location: {}
    });
    await devServerManager.startAsync([
        {
            type: "metro",
            options: {
                location: {},
                isExporting: true
            }
        }, 
    ]);
    try {
        await exportFromServerAsync(projectRoot, devServerManager, options);
    } finally{
        await devServerManager.stopAsync();
    }
}
/** Match `(page)` -> `page` */ function matchGroupName(name) {
    var ref;
    return (ref = name.match(/^\(([^/]+?)\)$/)) == null ? void 0 : ref[1];
}
async function getFilesToExportFromServerAsync(projectRoot, { manifest , renderAsync , includeGroupVariations  }) {
    // name : contents
    const files = new Map();
    await Promise.all(getHtmlFiles({
        manifest,
        includeGroupVariations
    }).map(async (outputPath)=>{
        const pathname = outputPath.replace(/(?:index)?\.html$/, "");
        try {
            files.set(outputPath, "");
            const data = await renderAsync(pathname);
            files.set(outputPath, data);
        } catch (e) {
            await (0, _metroErrorInterface).logMetroErrorAsync({
                error: e,
                projectRoot
            });
            throw new Error("Failed to statically export route: " + pathname);
        }
    }));
    return files;
}
async function exportFromServerAsync(projectRoot, devServerManager, { outputDir , basePath , exportServer , minify , includeMaps  }) {
    const { exp  } = (0, _config).getConfig(projectRoot, {
        skipSDKVersionRequirement: true
    });
    const appDir = (0, _router).getRouterDirectoryWithManifest(projectRoot, exp);
    const injectFaviconTag = await (0, _favicon).getVirtualFaviconAssetsAsync(projectRoot, {
        outputDir,
        basePath
    });
    const devServer = devServerManager.getDefaultDevServer();
    (0, _assert).default(devServer instanceof _metroBundlerDevServer.MetroBundlerDevServer);
    const [resources, { manifest , renderAsync  }] = await Promise.all([
        devServer.getStaticResourcesAsync({
            mode: "production",
            minify,
            includeMaps
        }),
        devServer.getStaticRenderFunctionAsync({
            mode: "production",
            minify
        }), 
    ]);
    debug("Routes:\n", (0, _util).inspect(manifest, {
        colors: true,
        depth: null
    }));
    const files = await getFilesToExportFromServerAsync(projectRoot, {
        manifest,
        // Servers can handle group routes automatically and therefore
        // don't require the build-time generation of every possible group
        // variation.
        includeGroupVariations: !exportServer,
        async renderAsync (pathname) {
            const template = await renderAsync(pathname);
            let html = await devServer.composeResourcesWithHtml({
                mode: "production",
                resources,
                template,
                basePath
            });
            if (injectFaviconTag) {
                html = injectFaviconTag(html);
            }
            return html;
        }
    });
    resources.forEach((resource)=>{
        files.set(resource.filename, modifyBundlesWithSourceMaps(resource.filename, resource.source, includeMaps));
    });
    if (exportServer) {
        const apiRoutes = await exportApiRoutesAsync({
            outputDir,
            server: devServer,
            appDir
        });
        // Add the api routes to the files to export.
        for (const [route, contents] of apiRoutes){
            files.set(route, contents);
        }
    } else {
        warnPossibleInvalidExportType(appDir);
    }
    _fs.default.mkdirSync(_path.default.join(outputDir), {
        recursive: true
    });
    _log.Log.log("");
    _log.Log.log(_chalk.default.bold`Exporting ${files.size} files:`);
    await Promise.all([
        ...files.entries()
    ].sort(([a], [b])=>a.localeCompare(b)
    ).map(async ([file, contents])=>{
        const length = Buffer.byteLength(contents, "utf8");
        _log.Log.log(file, _chalk.default.gray`(${(0, _prettyBytes).default(length)})`);
        const outputPath = _path.default.join(outputDir, file);
        await _fs.default.promises.mkdir(_path.default.dirname(outputPath), {
            recursive: true
        });
        await _fs.default.promises.writeFile(outputPath, contents);
    }));
    _log.Log.log("");
}
function modifyBundlesWithSourceMaps(filename, source, includeMaps) {
    if (filename.endsWith(".js")) {
        // If the bundle ends with source map URLs then update them to point to the correct location.
        // TODO: basePath support
        const normalizedFilename = "/" + filename.replace(/^\/+/, "");
        //# sourceMappingURL=//localhost:8085/index.map?platform=web&dev=false&hot=false&lazy=true&minify=true&resolver.environment=client&transform.environment=client&serializer.output=static
        //# sourceURL=http://localhost:8085/index.bundle//&platform=web&dev=false&hot=false&lazy=true&minify=true&resolver.environment=client&transform.environment=client&serializer.output=static
        return source.replace(/^\/\/# (sourceMappingURL|sourceURL)=.*$/gm, (...props)=>{
            if (includeMaps) {
                if (props[1] === "sourceURL") {
                    return `//# ${props[1]}=` + normalizedFilename;
                } else if (props[1] === "sourceMappingURL") {
                    const mapName = normalizedFilename + ".map";
                    return `//# ${props[1]}=` + mapName;
                }
            }
            return "";
        });
    }
    return source;
}
function getHtmlFiles({ manifest , includeGroupVariations  }) {
    const htmlFiles = new Set();
    function traverseScreens(screens, basePath = "") {
        for (const value of Object.values(screens)){
            if (typeof value === "string") {
                let filePath = basePath + value;
                if (value === "") {
                    filePath = basePath === "" ? "index" : basePath.endsWith("/") ? basePath + "index" : basePath.slice(0, -1);
                }
                if (includeGroupVariations) {
                    // TODO: Dedupe requests for alias routes.
                    addOptionalGroups(filePath);
                } else {
                    htmlFiles.add(filePath);
                }
            } else if (typeof value === "object" && (value == null ? void 0 : value.screens)) {
                const newPath = basePath + value.path + "/";
                traverseScreens(value.screens, newPath);
            }
        }
    }
    function addOptionalGroups(path) {
        const variations = getPathVariations(path);
        for (const variation of variations){
            htmlFiles.add(variation);
        }
    }
    traverseScreens(manifest.screens);
    return Array.from(htmlFiles).map((value)=>{
        const parts = value.split("/");
        // Replace `:foo` with `[foo]` and `*foo` with `[...foo]`
        const partsWithGroups = parts.map((part)=>{
            if (part === "*not-found") {
                return `+not-found`;
            } else if (part.startsWith(":")) {
                return `[${part.slice(1)}]`;
            } else if (part.startsWith("*")) {
                return `[...${part.slice(1)}]`;
            }
            return part;
        });
        return partsWithGroups.join("/") + ".html";
    });
}
function getPathVariations(routePath) {
    const variations = new Set();
    const segments1 = routePath.split("/");
    function generateVariations(segments, current = "") {
        if (segments.length === 0) {
            if (current) variations.add(current);
            return;
        }
        const [head, ...rest] = segments;
        if (head.startsWith("(foo,foo")) {}
        if (matchGroupName(head)) {
            const groups = head.slice(1, -1).split(",");
            if (groups.length > 1) {
                for (const group of groups){
                    // If there are multiple groups, recurse on each group.
                    generateVariations([
                        `(${group.trim()})`,
                        ...rest
                    ], current);
                }
                return;
            } else {
                // Start a fork where this group is included
                generateVariations(rest, current ? `${current}/(${groups[0]})` : `(${groups[0]})`);
            // This code will continue and add paths without this group included`
            }
        } else if (current) {
            current = `${current}/${head}`;
        } else {
            current = head;
        }
        generateVariations(rest, current);
    }
    generateVariations(segments1);
    return Array.from(variations);
}
async function exportApiRoutesAsync({ outputDir , server , appDir  }) {
    const functionsDir = "_expo/functions";
    const funcDir = _path.default.join(outputDir, functionsDir);
    _fs.default.mkdirSync(_path.default.join(funcDir), {
        recursive: true
    });
    const { manifest , files  } = await server.exportExpoRouterApiRoutesAsync({
        mode: "production",
        appDir,
        outputDir: functionsDir
    });
    _log.Log.log(_chalk.default.bold`Exporting ${files.size} API Routes.`);
    files.set("_expo/routes.json", JSON.stringify(manifest, null, 2));
    return files;
}
function warnPossibleInvalidExportType(appDir) {
    const apiRoutes = (0, _router).getApiRoutesForDirectory(appDir);
    if (apiRoutes.length) {
        // TODO: Allow API Routes for native-only.
        _log.Log.warn(_chalk.default.yellow`Skipping export for API routes because \`web.output\` is not "server". You may want to remove the routes: ${apiRoutes.map((v)=>_path.default.relative(appDir, v)
        ).join(", ")}`);
    }
}

//# sourceMappingURL=exportStaticAsync.js.map