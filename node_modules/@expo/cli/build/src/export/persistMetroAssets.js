"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.persistMetroAssetsAsync = persistMetroAssetsAsync;
exports.stripAssetPrefix = stripAssetPrefix;
var _fs = _interopRequireDefault(require("fs"));
var _path = _interopRequireDefault(require("path"));
var _log = require("../log");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
function persistMetroAssetsAsync(assets, { platform , outputDirectory , basePath  }) {
    const files = assets.reduce((acc, asset)=>{
        const validScales = new Set(filterPlatformAssetScales(platform, asset.scales));
        asset.scales.forEach((scale, idx)=>{
            if (!validScales.has(scale)) {
                return;
            }
            const src = asset.files[idx];
            const dest = _path.default.join(outputDirectory, getAssetLocalPath(asset, {
                scale,
                basePath
            }));
            acc[src] = dest;
        });
        return acc;
    }, {});
    return copyAll(files);
}
function copyAll(filesToCopy) {
    const queue = Object.keys(filesToCopy);
    if (queue.length === 0) {
        return;
    }
    _log.Log.log(`Copying ${queue.length} asset files`);
    return new Promise((resolve, reject)=>{
        const copyNext = (error)=>{
            if (error) {
                return reject(error);
            }
            if (queue.length) {
                // queue.length === 0 is checked in previous branch, so this is string
                const src = queue.shift();
                const dest = filesToCopy[src];
                copy(src, dest, copyNext);
            } else {
                _log.Log.log("Persisted assets");
                resolve();
            }
        };
        copyNext();
    });
}
function copy(src, dest, callback) {
    _fs.default.mkdir(_path.default.dirname(dest), {
        recursive: true
    }, (err)=>{
        if (err) {
            callback(err);
            return;
        }
        _fs.default.createReadStream(src).pipe(_fs.default.createWriteStream(dest)).on("finish", callback);
    });
}
const ALLOWED_SCALES = {
    ios: [
        1,
        2,
        3
    ]
};
function filterPlatformAssetScales(platform, scales) {
    const whitelist = ALLOWED_SCALES[platform];
    if (!whitelist) {
        return scales;
    }
    const result = scales.filter((scale)=>whitelist.includes(scale)
    );
    if (!result.length && scales.length) {
        // No matching scale found, but there are some available. Ideally we don't
        // want to be in this situation and should throw, but for now as a fallback
        // let's just use the closest larger image
        const maxScale = whitelist[whitelist.length - 1];
        for (const scale of scales){
            if (scale > maxScale) {
                result.push(scale);
                break;
            }
        }
        // There is no larger scales available, use the largest we have
        if (!result.length) {
            result.push(scales[scales.length - 1]);
        }
    }
    return result;
}
function getAssetLocalPath(asset, { basePath , scale  }) {
    const suffix = scale === 1 ? "" : `@${scale}x`;
    const fileName = `${asset.name + suffix}.${asset.type}`;
    const adjustedHttpServerLocation = stripAssetPrefix(asset.httpServerLocation, basePath);
    return _path.default.join(// Assets can have relative paths outside of the project root.
    // Replace `../` with `_` to make sure they don't end up outside of
    // the expected assets directory.
    adjustedHttpServerLocation.replace(/^\/+/g, "").replace(/\.\.\//g, "_"), fileName);
}
function stripAssetPrefix(path, basePath) {
    path = path.replace(/\/assets\?export_path=(.*)/, "$1");
    // TODO: Windows?
    if (basePath) {
        return path.replace(/^\/+/g, "").replace(new RegExp(`^${basePath.replace(/^\/+/g, "").replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d")}`, "g"), "");
    }
    return path;
}

//# sourceMappingURL=persistMetroAssets.js.map