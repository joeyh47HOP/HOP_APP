"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createRouteHandlerMiddleware = createRouteHandlerMiddleware;
var _server = require("@expo/server");
var _http = require("@expo/server/build/vendor/http");
var _requireFromString = _interopRequireDefault(require("require-from-string"));
var _resolve = _interopRequireDefault(require("resolve"));
var _util = require("util");
var _metroBundlerDevServer = require("./MetroBundlerDevServer");
var _bundleApiRoutes = require("./bundleApiRoutes");
var _fetchRouterManifest = require("./fetchRouterManifest");
var _metroErrorInterface = require("./metroErrorInterface");
var _log = require("../../../log");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
const debug = require("debug")("expo:start:server:metro");
const resolveAsync = (0, _util).promisify(_resolve.default);
function createRouteHandlerMiddleware(projectRoot, options) {
    return (0, _http).createRequestHandler({
        build: ""
    }, {
        async getRoutesManifest () {
            const manifest = await (0, _fetchRouterManifest).fetchManifest(projectRoot, options);
            debug("manifest", manifest);
            // NOTE: no app dir if null
            // TODO: Redirect to 404 page
            return manifest;
        },
        async getHtml (request) {
            try {
                const { content  } = await options.getStaticPageAsync(request.url);
                return content;
            } catch (error) {
                // Forward the Metro server response as-is. It won't be pretty, but at least it will be accurate.
                if (error instanceof _metroBundlerDevServer.ForwardHtmlError) {
                    return new _server.ExpoResponse(error.html, {
                        status: error.statusCode,
                        headers: {
                            "Content-Type": "text/html"
                        }
                    });
                }
                try {
                    return new _server.ExpoResponse(await (0, _metroErrorInterface).getErrorOverlayHtmlAsync({
                        error,
                        projectRoot
                    }), {
                        status: 500,
                        headers: {
                            "Content-Type": "text/html"
                        }
                    });
                } catch (staticError) {
                    // Fallback error for when Expo Router is misconfigured in the project.
                    return new _server.ExpoResponse("<span><h3>Internal Error:</h3><b>Project is not setup correctly for static rendering (check terminal for more info):</b><br/>" + error.message + "<br/><br/>" + staticError.message + "</span>", {
                        status: 500,
                        headers: {
                            "Content-Type": "text/html"
                        }
                    });
                }
            }
        },
        logApiRouteExecutionError (error) {
            (0, _metroErrorInterface).logMetroError(projectRoot, {
                error
            });
        },
        async getApiRoute (route) {
            const resolvedFunctionPath = await resolveAsync(route.page, {
                extensions: [
                    ".js",
                    ".jsx",
                    ".ts",
                    ".tsx"
                ],
                basedir: options.appDir
            });
            const middlewareContents = await (0, _bundleApiRoutes).bundleApiRoute(projectRoot, resolvedFunctionPath, options);
            if (!middlewareContents) {
                // TODO: Error handling
                return null;
            }
            try {
                debug(`Bundling middleware at: ${resolvedFunctionPath}`);
                return (0, _requireFromString).default(middlewareContents);
            } catch (error) {
                if (error instanceof Error) {
                    await (0, _metroErrorInterface).logMetroErrorAsync({
                        projectRoot,
                        error
                    });
                } else {
                    _log.Log.error("Failed to load middleware: " + error);
                }
                return new _server.ExpoResponse("Failed to load middleware: " + resolvedFunctionPath + "\n\n" + error.message, {
                    status: 500,
                    headers: {
                        "Content-Type": "text/html"
                    }
                });
            }
        }
    });
}

//# sourceMappingURL=createServerRouteMiddleware.js.map