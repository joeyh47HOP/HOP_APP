"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.createFastResolver = createFastResolver;
var _path = _interopRequireDefault(require("path"));
var _resolve = _interopRequireDefault(require("resolve"));
var _externals = require("./externals");
var _formatFileCandidates = require("./formatFileCandidates");
var _errors = require("../../../utils/errors");
function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
class FailedToResolvePathError extends Error {
}
class ShimModuleError extends Error {
}
function createFastResolver({ preserveSymlinks  }) {
    const cachedExtensions = new Map();
    function getAdjustedExtensions({ metroSourceExtensions , platform , isNative  }) {
        const key = JSON.stringify({
            metroSourceExtensions,
            platform,
            isNative
        });
        if (cachedExtensions.has(key)) {
            return cachedExtensions.get(key);
        }
        let output = metroSourceExtensions;
        if (platform) {
            const nextOutput = [];
            output.forEach((ext)=>{
                nextOutput.push(`${platform}.${ext}`);
                if (isNative) {
                    nextOutput.push(`native.${ext}`);
                }
                nextOutput.push(ext);
            });
            output = nextOutput;
        }
        output = Array.from(new Set(output));
        // resolve expects these to start with a dot.
        output = output.map((ext)=>`.${ext}`
        );
        cachedExtensions.set(key, output);
        return output;
    }
    function fastResolve(context, moduleName, platform) {
        var ref2;
        // TODO: Support extraNodeModules for tsconfig basePath support
        // TODO: Support package exports import { resolve as resolveExports } from 'resolve.exports'
        // TODO: Support `resolver.blockList`
        if (context.unstable_enablePackageExports) {
            throw new _errors.CommandError("package exports are not supported with EXPO_USE_FAST_RESOLVER=1");
        }
        const environment = (ref2 = context.customResolverOptions) == null ? void 0 : ref2.environment;
        const isServer = environment === "node";
        const extensions = getAdjustedExtensions({
            metroSourceExtensions: context.sourceExts,
            platform,
            isNative: context.preferNativePlatform
        });
        let fp;
        try {
            fp = _resolve.default.sync(moduleName, {
                basedir: _path.default.dirname(context.originModulePath),
                extensions,
                // Used to ensure files trace to packages instead of node_modules in expo/expo. This is how Metro works and
                // the app doesn't finish without it.
                preserveSymlinks,
                readPackageSync (readFileSync, pkgFile) {
                    var ref;
                    return (ref = context.getPackage(pkgFile)) != null ? ref : JSON.parse(// @ts-expect-error
                    readFileSync(pkgfile));
                },
                moduleDirectory: context.nodeModulesPaths,
                packageFilter (pkg) {
                    // set the pkg.main to the first available field in context.mainFields
                    for (const field of context.mainFields){
                        if (pkg[field] && // object-inspect uses browser: {} in package.json
                        typeof pkg[field] === "string") {
                            return {
                                ...pkg,
                                main: pkg[field]
                            };
                        }
                    }
                    return pkg;
                },
                pathFilter: isServer ? undefined : (pkg, _resolvedPath, relativePathIn)=>{
                    let relativePath = relativePathIn;
                    if (relativePath[0] !== ".") {
                        relativePath = `./${relativePath}`;
                    }
                    const replacements = pkg.browser;
                    if (replacements === undefined) {
                        return "";
                    }
                    var _relativePath;
                    // TODO: Probably use a better extension matching system here.
                    // This was added for `uuid/v4` -> `./lib/rng` -> `./lib/rng-browser.js`
                    const mappedPath = (_relativePath = replacements[relativePath]) != null ? _relativePath : replacements[relativePath + ".js"];
                    if (mappedPath === false) {
                        throw new ShimModuleError();
                    }
                    return mappedPath;
                },
                // Not needed but added for parity...
                // @ts-ignore
                realpathSync: context.unstable_getRealPath
            });
            if (!isServer && (0, _externals).isNodeExternal(fp)) {
                // In this case, mock the file to use an empty module.
                return {
                    type: "empty"
                };
            }
        } catch (error) {
            if (error instanceof ShimModuleError) {
                return {
                    type: "empty"
                };
            }
            if ("code" in error && error.code === "MODULE_NOT_FOUND") {
                // TODO: Add improved error handling.
                throw new FailedToResolvePathError("The module could not be resolved because no file or module matched the pattern:\n" + `  ${(0, _formatFileCandidates).formatFileCandidates({
                    type: "sourceFile",
                    filePathPrefix: moduleName,
                    candidateExts: extensions
                }, true)}\n\n`);
            }
            throw error;
        }
        if (context.sourceExts.some((ext)=>fp.endsWith(ext)
        )) {
            return {
                type: "sourceFile",
                filePath: fp
            };
        } else {
            // NOTE: platform extensions may not be supported on assets.
            if (platform === "web") {
                // Skip multi-resolution on web/server bundles. Only consideration here is that
                // we may still need it in case the only image is a multi-resolution image.
                return {
                    type: "assetFiles",
                    filePaths: [
                        fp
                    ]
                };
            }
            const dirPath = _path.default.dirname(fp);
            const extension = _path.default.extname(fp);
            const basename = _path.default.basename(fp, extension);
            var ref1;
            return {
                type: "assetFiles",
                // Support multi-resolution asset extensions...
                filePaths: (ref1 = context.resolveAsset(dirPath, basename, extension)) != null ? ref1 : [
                    fp
                ]
            };
        }
    }
    return fastResolve;
}

//# sourceMappingURL=createExpoMetroResolver.js.map