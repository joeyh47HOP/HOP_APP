{"version":3,"sources":["../../../../../src/start/server/metro/bundleApiRoutes.ts"],"sourcesContent":["/**\n * Copyright Â© 2022 650 Industries.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\nimport { logMetroErrorAsync } from './metroErrorInterface';\nimport { requireFileContentsWithMetro } from '../getStaticRenderFunctions';\n\nconst debug = require('debug')('expo:server-routes') as typeof console.log;\n\nconst pendingRouteOperations = new Map<string, Promise<string | null>>();\n\nexport type ApiRouteOptions = {\n  mode?: string;\n  appDir: string;\n  port?: number;\n  shouldThrow?: boolean;\n};\n\n// Bundle the API Route with Metro and return the string contents to be evaluated in the server.\nexport async function bundleApiRoute(\n  projectRoot: string,\n  filepath: string,\n  options: ApiRouteOptions\n): Promise<string | null | undefined> {\n  if (pendingRouteOperations.has(filepath)) {\n    return pendingRouteOperations.get(filepath);\n  }\n\n  const devServerUrl = `http://localhost:${options.port}`;\n\n  async function bundleAsync() {\n    try {\n      debug('Check API route:', options.appDir, filepath);\n\n      const middleware = await requireFileContentsWithMetro(projectRoot, devServerUrl, filepath, {\n        minify: options.mode === 'production',\n        dev: options.mode !== 'production',\n        // Ensure Node.js\n        environment: 'node',\n      });\n\n      return middleware;\n    } catch (error: any) {\n      if (error instanceof Error) {\n        await logMetroErrorAsync({ error, projectRoot });\n      }\n      if (options.shouldThrow) {\n        throw error;\n      }\n      // TODO: improve error handling, maybe have this be a mock function which returns the static error html\n      return null;\n    } finally {\n      // pendingRouteOperations.delete(filepath);\n    }\n  }\n  const route = bundleAsync();\n\n  pendingRouteOperations.set(filepath, route);\n  return route;\n}\n\nexport async function rebundleApiRoute(\n  projectRoot: string,\n  filepath: string,\n  options: ApiRouteOptions\n) {\n  pendingRouteOperations.delete(filepath);\n  return bundleApiRoute(projectRoot, filepath, options);\n}\n"],"names":["bundleApiRoute","rebundleApiRoute","debug","require","pendingRouteOperations","Map","projectRoot","filepath","options","has","get","devServerUrl","port","bundleAsync","appDir","middleware","requireFileContentsWithMetro","minify","mode","dev","environment","error","Error","logMetroErrorAsync","shouldThrow","route","set","delete"],"mappings":"AAOA;;;;QAesBA,cAAc,GAAdA,cAAc;QA0CdC,gBAAgB,GAAhBA,gBAAgB;AAzDH,IAAA,oBAAuB,WAAvB,uBAAuB,CAAA;AACb,IAAA,yBAA6B,WAA7B,6BAA6B,CAAA;AAE1E,MAAMC,KAAK,GAAGC,OAAO,CAAC,OAAO,CAAC,CAAC,oBAAoB,CAAC,AAAsB,AAAC;AAE3E,MAAMC,sBAAsB,GAAG,IAAIC,GAAG,EAAkC,AAAC;AAUlE,eAAeL,cAAc,CAClCM,WAAmB,EACnBC,QAAgB,EAChBC,OAAwB,EACY;IACpC,IAAIJ,sBAAsB,CAACK,GAAG,CAACF,QAAQ,CAAC,EAAE;QACxC,OAAOH,sBAAsB,CAACM,GAAG,CAACH,QAAQ,CAAC,CAAC;KAC7C;IAED,MAAMI,YAAY,GAAG,CAAC,iBAAiB,EAAEH,OAAO,CAACI,IAAI,CAAC,CAAC,AAAC;IAExD,eAAeC,WAAW,GAAG;QAC3B,IAAI;YACFX,KAAK,CAAC,kBAAkB,EAAEM,OAAO,CAACM,MAAM,EAAEP,QAAQ,CAAC,CAAC;YAEpD,MAAMQ,UAAU,GAAG,MAAMC,CAAAA,GAAAA,yBAA4B,AAKnD,CAAA,6BALmD,CAACV,WAAW,EAAEK,YAAY,EAAEJ,QAAQ,EAAE;gBACzFU,MAAM,EAAET,OAAO,CAACU,IAAI,KAAK,YAAY;gBACrCC,GAAG,EAAEX,OAAO,CAACU,IAAI,KAAK,YAAY;gBAClC,iBAAiB;gBACjBE,WAAW,EAAE,MAAM;aACpB,CAAC,AAAC;YAEH,OAAOL,UAAU,CAAC;SACnB,CAAC,OAAOM,KAAK,EAAO;YACnB,IAAIA,KAAK,YAAYC,KAAK,EAAE;gBAC1B,MAAMC,CAAAA,GAAAA,oBAAkB,AAAwB,CAAA,mBAAxB,CAAC;oBAAEF,KAAK;oBAAEf,WAAW;iBAAE,CAAC,CAAC;aAClD;YACD,IAAIE,OAAO,CAACgB,WAAW,EAAE;gBACvB,MAAMH,KAAK,CAAC;aACb;YACD,uGAAuG;YACvG,OAAO,IAAI,CAAC;SACb,QAAS;QACR,2CAA2C;SAC5C;KACF;IACD,MAAMI,KAAK,GAAGZ,WAAW,EAAE,AAAC;IAE5BT,sBAAsB,CAACsB,GAAG,CAACnB,QAAQ,EAAEkB,KAAK,CAAC,CAAC;IAC5C,OAAOA,KAAK,CAAC;CACd;AAEM,eAAexB,gBAAgB,CACpCK,WAAmB,EACnBC,QAAgB,EAChBC,OAAwB,EACxB;IACAJ,sBAAsB,CAACuB,MAAM,CAACpB,QAAQ,CAAC,CAAC;IACxC,OAAOP,cAAc,CAACM,WAAW,EAAEC,QAAQ,EAAEC,OAAO,CAAC,CAAC;CACvD"}